[["index.html", "人口学研究におけるRの活用 Rによるカテゴリカルデータ分析：多重クロス表 このサイトについて", " 人口学研究におけるRの活用 Rによるカテゴリカルデータ分析：多重クロス表 余田翔平（国立社会保障・人口問題研究所） 2023-03-22 このサイトについて このサイトは日本人口学会による研究集会「人口学研究におけるRの活用」（2023年3月22日）の報告資料および演習用ページです。研究集会は学会員限定ですが、本サイトはどなたでも閲覧可能です。研究集会後も本資料は修正・更新される可能性があります。 "],["はじめに.html", "Chapter 1 はじめに 1.1 本報告の目的 1.2 人口学的分析への適用例：学歴同類婚", " Chapter 1 はじめに 1.1 本報告の目的 Rの配列（array）の処理を多重クロス集計表（contingency table）の分析に適用する 基本統計量（行／列パーセント）の算出とその可視化 1.2 人口学的分析への適用例：学歴同類婚 Who marries whom? 社会の開放性（社会学） 世帯間の経済格差（経済学） 出生の近接要因としての結婚（人口学）   学歴同類婚の方法論については Lichter and Qian (2019) に詳しい 比率・相関 オッズ比 対数線形モデル Forces of Attraction regression based approaches (e.g., イベントヒストリーモデル）   本報告では1に依拠し、夫婦の学歴組み合わせを示すクロス集計表を分析 日本の学歴同類婚の最近の動向については Uchikoshi and Raymo (2021) を参照 Reference "],["データの読み込み.html", "Chapter 2 データの読み込み 2.1 CSVファイルの読み込み 2.2 CSVファイルの出力", " Chapter 2 データの読み込み 本報告では Fukuda, Yoda, and Mogi (2021) のSupplemental Tableとして掲載されているデータを用いる。これは「国勢調査」の調査票情報を用いて、妻が30-39歳の夫婦の学歴組み合わせを示すクロス集計表である。例えば、以下は1980年の「国勢調査」にもとづく夫婦の学歴組み合わせである。 ## EduH ## EduW JHS HS VC/JC UNI ## JHS 1825957.2 692306.05 25961.477 43269.13 ## HS 744229.0 3106723.41 164422.687 856728.74 ## VC/JC 34615.3 207691.82 69230.605 493268.06 ## UNI 0.0 25961.48 8653.826 337499.20 表側には妻の学歴（EduW）、表頭には夫の学歴（EduH）がそれぞれ置かれている。ここに調査年（CensusYear）を追加すると、妻の学歴×夫の学歴×調査年の3変数からなる多元クロス集計表を作成することができる。 本報告では、上のようなクロス集計表のデータが事前に与えられている状況を想定して進めていく。具体的には、「国勢調査」の調査年別に\\(4\\times4=16\\)セルの度数がCSVファイルなどで与えられているものとする。そのため、以下ではCSVファイルの出入力の基本操作を押さえておこう。 2.1 CSVファイルの読み込み まず、本報告で用いるCSVファイルはCensusCSV/CSV_EduWHフォルダに保存されている。ここには1980年、1990年、2000年、2010年の「国勢調査」を用いて集計された夫婦の学歴組み合わせのデータファイルが調査年ごとに保存されている。例えば、以下は1980年調査のデータファイルである1。 夫婦の学歴組み合わせ：1980年 CSVファイルの読み込みにはread.csv()を用いる。この関数に最低限必要な引数は、読み込みの対象となるCSVファイルのパス（file）である。CSVファイルがワーキングディレクトリと同じ階層に保存されている場合はファイル名を文字列で引き渡せばよい。CSVファイルが異なる階層に保存されている場合は、相対パスあるいはフルパスでファイルの場所を指定する。その際、報告者個人が推奨する方法は、CSVファイルが保存されているフォルダのパスをオブジェクトと保存しておき、そのオブジェクトとファイル名の文字列とをpaste()あるいはpaste0()で結合する方法である2。このようにしておくと、CSVファイルの保存場所が変更された場合でも、そのフォルダパスを示すオブジェクトのみを修正すればそれ以外のコードを修正する必要がないためである。 また、今回の例には当てはまらないが、1行目が変数名となっている場合は、header = TRUEとすると（むしろ、こちらがデフォルトの設定）1行目は変数名として処理され、2行目からobservationとして認識される。 CensusDir &lt;- &quot;CensusCSV/CSV_EduWH/&quot; FN_EduWH1980csv &lt;- paste0(CensusDir, &quot;EduWH1980.csv&quot;) EduWH1980_raw &lt;- read.csv(file = FN_EduWH1980csv, header = FALSE) # &quot;file = &quot;は省略可 read.csv()でデータを読み込んだ直後のオブジェクトの型はデータフレームになっている。今回raw dataとして読み込んだのは行列の形をしたクロス集計表であるため、以下のように行列に変換する必要がある。 # CSVファイルを読み込んだ直後の型はデータフレームになっている class(EduWH1980_raw) ## [1] &quot;data.frame&quot; # as.matrix()でオブジェクトの型を行列に変換 EduWH1980_mat &lt;- as.matrix(EduWH1980_raw) class(EduWH1980_mat) ## [1] &quot;matrix&quot; &quot;array&quot; EduWH1980_mat ## V1 V2 V3 V4 ## [1,] 1825957.2 692306.05 25961.477 43269.13 ## [2,] 744229.0 3106723.41 164422.687 856728.74 ## [3,] 34615.3 207691.82 69230.605 493268.06 ## [4,] 0.0 25961.48 8653.826 337499.20 こうしてデータの型をデータフレームから行列に変換できたものの、この段階では各行および各列がそれぞれどのカテゴリを示すのかが明瞭ではない。そこで、dimnames()を用いて行列の次元にラベルをつけておくと便利である。dimnames()はオブジェクトの各次元のラベルをリスト（list）として返す関数である。 EduWH1980 &lt;- EduWH1980_mat class(dimnames(EduWH1980)) ## [1] &quot;list&quot; dimnames(EduWH1980) ## [[1]] ## NULL ## ## [[2]] ## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; 列（column）のラベル（“V1”-“V4”）のみが保存されており、行ラベルは空であることがわかる。夫婦の学歴カテゴリを示すラベルを付与するためには以下のようにリストとして代入する。 dimnames(EduWH1980) &lt;- list(c(&quot;JHS&quot;, &quot;HS&quot;, &quot;VC/JC&quot;, &quot;UNI&quot;), c(&quot;JHS&quot;, &quot;HS&quot;, &quot;VC/JC&quot;, &quot;UNI&quot;)) EduWH1980 ## JHS HS VC/JC UNI ## JHS 1825957.2 692306.05 25961.477 43269.13 ## HS 744229.0 3106723.41 164422.687 856728.74 ## VC/JC 34615.3 207691.82 69230.605 493268.06 ## UNI 0.0 25961.48 8653.826 337499.20 行カテゴリ・列カテゴリが付与されたが、さらにnames()とdimnames()とを組み合わせることで行方向・列方向それぞれの変数名も付与できる。 names(dimnames(EduWH1980)) &lt;- c(&quot;EduW&quot;, &quot;EduH&quot;) # 完成! EduWH1980 ## EduH ## EduW JHS HS VC/JC UNI ## JHS 1825957.2 692306.05 25961.477 43269.13 ## HS 744229.0 3106723.41 164422.687 856728.74 ## VC/JC 34615.3 207691.82 69230.605 493268.06 ## UNI 0.0 25961.48 8653.826 337499.20 2.2 CSVファイルの出力 つづいて、Rの上で作成したオブジェクトを外部ファイルに出力する方法について見ておこう。オブジェクトはさまざまなフォーマットで出力可能であるが、ここではCSVファイルの出力方法について説明する。 2.2.1 出力するオブジェクトの準備 前節ではすでに調査年ごとのクロス集計表がCSVファイルの形式で用意されていることを前提に、CSVファイルを読み込む方法を見てきた。しかしながら、Fukuda, Yoda, and Mogi (2021) で公表されているのは、以下のように、調査年ごとの夫婦学歴組み合わせのクロス集計表の全体度数と全体パーセントのみである。 Fukuda et al.(2021) そこで、これらの情報に基づいてクロス集計表のセル度数を算出し、それらをCSVファイルに出力してみよう。例として2010年のクロス集計表を取り上げる。まず、以下のように全体パーセントを入力したデータをCSVファイルとして保存しておく。 2010年のクロス集計表（全体パーセント）：TotProp2010.csv つぎに、このCSVファイルをRに取り込んでおく。 # パラメータの設定 SupTabsDir &lt;- &quot;CensusCSV/SupplementalTables/&quot; # 全体パーセントのCSVファイルが保存されているディレクトリ OutDir &lt;- &quot;CensusCSV/CSV_EduWH/&quot; # 出力先ディレクトリ NofObs &lt;- 481536 # 全体度数 # 全体パーセントの読み込み TotProp2010_raw &lt;- read.csv(paste0(SupTabsDir, &quot;TotProp2010.csv&quot;), header = FALSE) TotProp2010 &lt;- as.matrix(TotProp2010_raw) TotProp2010 ## V1 V2 V3 V4 ## [1,] 1.0 1.5 0.2 0.3 ## [2,] 2.8 23.6 4.4 7.5 ## [3,] 1.1 12.2 8.1 16.4 ## [4,] 0.2 2.8 1.8 16.1 クロス集計表の全体パーセントを行列として読み込めたら、あとはそれらを比率に変換した上で全体度数を乗じればセル度数が得られるので、 # セル度数の算出 EduWH2010 &lt;- NofObs * (TotProp2010 / 100) EduWH2010 ## V1 V2 V3 V4 ## [1,] 4815.360 7223.04 963.072 1444.608 ## [2,] 13483.008 113642.50 21187.584 36115.200 ## [3,] 5296.896 58747.39 39004.416 78971.904 ## [4,] 963.072 13483.01 8667.648 77527.296 とすれば、2010年の夫婦の学歴組み合わせのクロス集計表が得られる。 2.2.2 write.csv() CSVファイルを出力するための関数のひとつがwrite.csv()である。第1の引数として保存するオブジェクト名を指定し、fileには保存するファイル名を（パスも含めて）指定する。row.names = FALSEを指定しないと、第1列目に行ラベル（ない場合は行番号）が表示される。 write.csv(EduWH2010, file = paste0(OutDir, &quot;EduWH2010_writecsv.csv&quot;), row.names = FALSE) 保存されたCSVファイルを開いてみると、第1行目に列名（変数名）が表示されていることがわかる。このままでも必要な情報（セル度数）は保存されているので大きな問題ではないが、列名も表示させたくない場合はwrite.table()を使うと良い。 write.csv()で出力されたCSV 2.2.3 write.table() write.table()ではcol.namesという引数を指定でき、これをFALSEにすると列名が表示されなくなる。この関数を用いてCSVファイルを出力する際にはセパレータsepをカンマにしておく。 write.table(EduWH2010, file = paste0(OutDir, &quot;EduWH2010.csv&quot;), sep = &quot;,&quot;, row.names = FALSE, col.names = FALSE) 保存されたCSVファイルを確認すると、列名が保存されていないことがわかる。 write.table()で出力されたCSV Reference "],["二元クロス集計表の処理.html", "Chapter 3 二元クロス集計表の処理 3.1 周辺度数の追加 3.2 比率（proportion）の算出", " Chapter 3 二元クロス集計表の処理 3.1 周辺度数の追加 すでに見た夫婦の学歴組み合わせのクロス集計表には行方向・列方向ともに周辺度数（marginal frequency）がついていない。これはxtabs()やtable()などの関数を用いて個票データからクロス集計表を作成した場合も同様である。クロス集計表に周辺度数を追加するためにはaddmargins()を用いる。 # 行周辺度数 addmargins(EduWH1980, margin = 1) ## EduH ## EduW JHS HS VC/JC UNI ## JHS 1825957.2 692306.05 25961.477 43269.13 ## HS 744229.0 3106723.41 164422.687 856728.74 ## VC/JC 34615.3 207691.82 69230.605 493268.06 ## UNI 0.0 25961.48 8653.826 337499.20 ## Sum 2604801.5 4032682.75 268268.595 1730765.13 # 列周辺度数 addmargins(EduWH1980, margin = 2) ## EduH ## EduW JHS HS VC/JC UNI Sum ## JHS 1825957.2 692306.05 25961.477 43269.13 2587493.9 ## HS 744229.0 3106723.41 164422.687 856728.74 4872103.8 ## VC/JC 34615.3 207691.82 69230.605 493268.06 804805.8 ## UNI 0.0 25961.48 8653.826 337499.20 372114.5 # 行／列周辺度数 addmargins(EduWH1980, margin = c(1,2)) ## EduH ## EduW JHS HS VC/JC UNI Sum ## JHS 1825957.2 692306.05 25961.477 43269.13 2587493.9 ## HS 744229.0 3106723.41 164422.687 856728.74 4872103.8 ## VC/JC 34615.3 207691.82 69230.605 493268.06 804805.8 ## UNI 0.0 25961.48 8653.826 337499.20 372114.5 ## Sum 2604801.5 4032682.75 268268.595 1730765.13 8636518.0 3.2 比率（proportion）の算出 クロス集計表の分析においておそらく最も頻繁に行うのが比率（proportion）の計算である。Rにはこれを可能にする数多くのパッケージおよび関数が存在するが、以下ではbaseに組み込まれているproportions()、およびRcmdrMiscパッケージのrowPercents()・colPercents()を紹介する。 3.2.1 proportions() この関数はmarginという引数を持ち、1は行方向、2は列方向にそれぞれ算出した「比率」を返す。 proportions(EduWH1980, margin = 1) * 100 # 行パーセント ## EduH ## EduW JHS HS VC/JC UNI ## JHS 70.568562 26.755853 1.003344 1.672241 ## HS 15.275311 63.765542 3.374778 17.584369 ## VC/JC 4.301075 25.806452 8.602151 61.290323 ## UNI 0.000000 6.976744 2.325581 90.697674 proportions(EduWH1980, margin = 2) * 100 # 列パーセント ## EduH ## EduW JHS HS VC/JC UNI ## JHS 70.099668 17.1673820 9.677419 2.5 ## HS 28.571429 77.0386266 61.290323 49.5 ## VC/JC 1.328904 5.1502146 25.806452 28.5 ## UNI 0.000000 0.6437768 3.225806 19.5 # 有効桁数を減らしたい場合は&quot;round&quot;で丸めるとよい round(proportions(EduWH1980, margin = 1) * 100, digits = 1) # &quot;digits = &quot;は省略してもよい ## EduH ## EduW JHS HS VC/JC UNI ## JHS 70.6 26.8 1.0 1.7 ## HS 15.3 63.8 3.4 17.6 ## VC/JC 4.3 25.8 8.6 61.3 ## UNI 0.0 7.0 2.3 90.7 tableの次元に名前がついている場合、marginには次元名を指定することもできる proportions(EduWH1980, margin = &quot;EduW&quot;) ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.70568562 0.26755853 0.01003344 0.01672241 ## HS 0.15275311 0.63765542 0.03374778 0.17584369 ## VC/JC 0.04301075 0.25806452 0.08602151 0.61290323 ## UNI 0.00000000 0.06976744 0.02325581 0.90697674 proportions(EduWH1980, margin = &quot;EduH&quot;) ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.70099668 0.171673820 0.09677419 0.025 ## HS 0.28571429 0.770386266 0.61290323 0.495 ## VC/JC 0.01328904 0.051502146 0.25806452 0.285 ## UNI 0.00000000 0.006437768 0.03225806 0.195 周辺度数をつけてからproportions()に引き渡せば行全体あるいは列全体の変数の分布を算出できる。 EduWH1980_wRMar &lt;- addmargins(EduWH1980, margin = 1) # w/ row margins round(proportions(EduWH1980_wRMar, margin = 1) * 100, digits = 1) ## EduH ## EduW JHS HS VC/JC UNI ## JHS 70.6 26.8 1.0 1.7 ## HS 15.3 63.8 3.4 17.6 ## VC/JC 4.3 25.8 8.6 61.3 ## UNI 0.0 7.0 2.3 90.7 ## Sum 30.2 46.7 3.1 20.0 EduWH1980_wCMar &lt;- addmargins(EduWH1980, margin = 2) # w/ column margins round(proportions(EduWH1980_wCMar, margin = 2) * 100, digits = 1) ## EduH ## EduW JHS HS VC/JC UNI Sum ## JHS 70.1 17.2 9.7 2.5 30.0 ## HS 28.6 77.0 61.3 49.5 56.4 ## VC/JC 1.3 5.2 25.8 28.5 9.3 ## UNI 0.0 0.6 3.2 19.5 4.3 3.2.2 rowPercents()・colPercents() RcmdrMiscパッケージのrowPercents()やcolPercents()を使っても行パーセントや列パーセントを算出できる。proportions()と比較した際のこれらの関数の便利な点は、デフォルトで周辺度数を出力結果に返してくれることである。 library(RcmdrMisc) rowPercents(EduWH1980, digits = 1) ## EduH ## EduW JHS HS VC/JC UNI Total Count ## JHS 70.6 26.8 1.0 1.7 100.1 2587493.9 ## HS 15.3 63.8 3.4 17.6 100.1 4872103.8 ## VC/JC 4.3 25.8 8.6 61.3 100.0 804805.8 ## UNI 0.0 7.0 2.3 90.7 100.0 372114.5 colPercents(EduWH1980, digits = 1) ## EduH ## EduW JHS HS VC/JC UNI ## JHS 70.1 17.2 9.7 2.5 ## HS 28.6 77.0 61.3 49.5 ## VC/JC 1.3 5.2 25.8 28.5 ## UNI 0.0 0.6 3.2 19.5 ## Total 100.0 100.0 100.0 100.0 ## Count 2604801.5 4032682.8 268268.6 1730765.1 "],["多元クロス集計表の処理.html", "Chapter 4 多元クロス集計表の処理 4.1 配列（array） 4.2 abind()を用いた配列の作成 4.3 apply()を用いた配列の処理 4.4 apply()と自作関数を組み合わせる", " Chapter 4 多元クロス集計表の処理 つぎに、変数が3つ以上の多元クロス集計表の処理について見ていく。例えば、夫婦の学歴組み合わせのクロス集計表が複数の調査年について得られている状況を想定してみよう。この場合、 妻の学歴 × 夫の学歴 × 調査年 の3変数からなる多元クロス集計表が得られることになる。こうした多元クロス集計表をRの中で表現・処理する方法はいくつかあるが、以下では配列（array）を用いた方法について紹介する。 4.1 配列（array） 配列（array）とは行列（matrix）を三次元以上に一般化したものである。言い換えると、二次元の配列は行列として処理することができる。Rで配列を作成する方法は主に2つある。 関数array()を用いて配列を直接作成する 複数の行列をabind()で結合する 以下、順に見ていこう。まずは関数array()の使用方法についてである。 # 2×2×2の3次元からなり、要素がすべてNAの空の配列 array(data = NA, dim = c(2,2,2)) ## , , 1 ## ## [,1] [,2] ## [1,] NA NA ## [2,] NA NA ## ## , , 2 ## ## [,1] [,2] ## [1,] NA NA ## [2,] NA NA # 任意のベクトルを引き渡してもよい。列方向に順番に格納されていく。 array(data = 1:8, dim = c(2,2,2)) ## , , 1 ## ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## ## , , 2 ## ## [,1] [,2] ## [1,] 5 7 ## [2,] 6 8 # データとして引き渡したベクトルの長さが次元の長さの積と等しくない場合、配列が埋まるまでデータのベクトルが反復される array(data = 1:3, dim = c(2,2,2)) ## , , 1 ## ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 1 ## ## , , 2 ## ## [,1] [,2] ## [1,] 2 1 ## [2,] 3 2 ただし、報告者の個人的な経験からすると、array()を用いて分析対象とするクロス集計表を直接作成することはあまりない。むしろ、array()が活躍するのは以下のような場面である。 既存の配列の次元の長さを増やす 仮想的な配列のデータを作成して、自身が作成した関数が意図した通りの挙動で動くかを確認する 4.2 abind()を用いた配列の作成 クロス集計表がraw dataとして与えられている場合、それらをもとに多元クロス集計表を表す配列を作成する方法は、複数のクロス集計表を行列として読み込み、それらを結合することである。その際に用いる関数がabind()である。以下、この関数の使い方を見ていこう。 はじめに問題になるのは複数のクロス集計表を読み込む方法である。最も愚直な方法は、CSVファイルを読み込むためのコードを調査年ごとに書くことである。 EduWH1980_raw &lt;- read.csv(paste0(CensusDir, &quot;EduWH1980.csv&quot;), header = FALSE) EduWH1990_raw &lt;- read.csv(paste0(CensusDir, &quot;EduWH1990.csv&quot;), header = FALSE) EduWH1980 &lt;- as.matrix(EduWH1980_raw) EduWH1990 &lt;- as.matrix(EduWH1990_raw) dimnames(EduWH1980) &lt;- dimnames(EduWH1990) &lt;- list(c(&quot;JHS&quot;, &quot;HS&quot;, &quot;VC/JC&quot;, &quot;UNI&quot;), c(&quot;JHS&quot;, &quot;HS&quot;, &quot;VC/JC&quot;, &quot;UNI&quot;)) names(dimnames(EduWH1980)) &lt;- names(dimnames(EduWH1990)) &lt;- c(&quot;EduW&quot;, &quot;EduH&quot;) 読み込むデータファイルが数個程度であればこの方法でも大きな問題は生じないが、歴史の長い反服横断調査やパネル調査ほど読み込むべきデータファイルの数は増えていく。その場合、調査回ごとにデータ読み込みのプログラムを書くのではなく、データ読み込みのための自前の関数を作ってしまうと便利である。例えば、以下ではreadEduWH()という関数を定義している。 readEduWH &lt;- function(path, census_year){ TargetCSV &lt;- paste0(path, &quot;EduWH&quot;, as.character(census_year), &quot;.csv&quot;) # 例えば1980年のデータファイル名は&quot;EduWH1980.csv&quot;にしておく EduWH_raw &lt;- read.csv(TargetCSV, header = FALSE) EduWH_mat &lt;- as.matrix(EduWH_raw) EduWH &lt;- EduWH_mat dimnames(EduWH) &lt;- list(c(&quot;JHS&quot;, &quot;HS&quot;, &quot;VC/JC&quot;, &quot;UNI&quot;), c(&quot;JHS&quot;, &quot;HS&quot;, &quot;VC/JC&quot;, &quot;UNI&quot;)) return(EduWH) } この関数は引数としてcensus_yearを持ち、ここに読み込みたい国勢調査の調査年を引き渡すと、その調査年の夫婦の学歴組み合わせのCSVファイルが読み込まれて（ただし、そのためにはCSVのファイル名に調査年を含めておく必要がある）返り値として出力される。例えば、1980年の国勢調査データを読み込むためには、 readEduWH(path = CensusDir, census_year = 1980) ## JHS HS VC/JC UNI ## JHS 1825957.2 692306.05 25961.477 43269.13 ## HS 744229.0 3106723.41 164422.687 856728.74 ## VC/JC 34615.3 207691.82 69230.605 493268.06 ## UNI 0.0 25961.48 8653.826 337499.20 とすればよい。この自作関数とabind()とを組み合わせることで、以下のように1980年から2010年までの4回の国勢調査データをひとつの配列に格納することができる。 library(abind) CensusYearList &lt;- seq(1980, 2010, 10) # 国勢調査の調査年が格納されたベクトル EduWH &lt;- NULL # 空のオブジェクトを作っておく for(iYear in CensusYearList){ EduWH_temp &lt;- readEduWH(path = CensusDir, census_year = iYear) # iYear年の国勢調査のデータを読み込む EduWH &lt;- abind(EduWH, EduWH_temp, along = 3) # その結果を事前に作っておいたEduWHに順次結合していく } dimnames(EduWH)[[3]] &lt;- CensusYearList # abindで結合した次元にはラベルがついていないのでつけておくと便利 names(dimnames(EduWH)) &lt;- c(&quot;EduW&quot;, &quot;EduH&quot;, &quot;CensusYear&quot;) # 各次元の変数名を付与 オブジェクトEduWHに4回の国勢調査における夫婦の学歴組み合わせのクロス集計表が保存されているか確認してみよう。 EduWH ## , , CensusYear = 1980 ## ## EduH ## EduW JHS HS VC/JC UNI ## JHS 1825957.2 692306.05 25961.477 43269.13 ## HS 744229.0 3106723.41 164422.687 856728.74 ## VC/JC 34615.3 207691.82 69230.605 493268.06 ## UNI 0.0 25961.48 8653.826 337499.20 ## ## , , CensusYear = 1990 ## ## EduH ## EduW JHS HS VC/JC UNI ## JHS 434278.720 244281.78 13571.21 20356.81 ## HS 474992.350 2497102.64 189996.94 712488.53 ## VC/JC 61070.445 474992.35 162854.52 821058.20 ## UNI 6785.605 61070.44 13571.21 597133.24 ## ## , , CensusYear = 2000 ## ## EduH ## EduW JHS HS VC/JC UNI ## JHS 91394.56 114243.20 11424.32 17136.48 ## HS 222774.24 1902149.28 228486.40 605488.96 ## VC/JC 45697.28 542655.20 274183.68 925369.92 ## UNI 5712.16 74258.08 34272.96 611201.12 ## ## , , CensusYear = 2010 ## ## EduH ## EduW JHS HS VC/JC UNI ## JHS 48150.360 72225.54 9630.072 14445.11 ## HS 134821.008 1136348.50 211861.584 361127.70 ## VC/JC 52965.396 587434.39 390017.916 789665.90 ## UNI 9630.072 134821.01 86670.648 775220.80 このように、妻の学歴（EduW）×夫の学歴（EduH）×調査年（CensusYear）からなる三元クロス表が配列として表現できたことがわかる。 4.3 apply()を用いた配列の処理 apply()は、行列あるいは配列の特定の次元ごとに何らかの処理を並列的に施すための関数である。例えば、夫婦の学歴組み合わせの分布（すなわち全体パーセント）を調査年ごとに算出するためには、 apply(EduWH, MARGIN = 3, FUN = proportions, simplify = FALSE) # &quot;MARGIN =&quot;, &quot;FUN = &quot;の部分は省略してもよい ## $`1980` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.211422846 0.080160321 0.003006012 0.00501002 ## HS 0.086172345 0.359719439 0.019038076 0.09919840 ## VC/JC 0.004008016 0.024048096 0.008016032 0.05711423 ## UNI 0.000000000 0.003006012 0.001002004 0.03907816 ## ## $`1990` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.064 0.036 0.002 0.003 ## HS 0.070 0.368 0.028 0.105 ## VC/JC 0.009 0.070 0.024 0.121 ## UNI 0.001 0.009 0.002 0.088 ## ## $`2000` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.016016016 0.02002002 0.002002002 0.003003003 ## HS 0.039039039 0.33333333 0.040040040 0.106106106 ## VC/JC 0.008008008 0.09509510 0.048048048 0.162162162 ## UNI 0.001001001 0.01301301 0.006006006 0.107107107 ## ## $`2010` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.010 0.015 0.002 0.003 ## HS 0.028 0.236 0.044 0.075 ## VC/JC 0.011 0.122 0.081 0.164 ## UNI 0.002 0.028 0.018 0.161 とすればよい。なお、配列の次元にラベルをつけている場合、そのラベルを用いて引数MARGINに引き渡すこともできる。 apply(EduWH, &quot;CensusYear&quot;, proportions, simplify = FALSE) ## $`1980` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.211422846 0.080160321 0.003006012 0.00501002 ## HS 0.086172345 0.359719439 0.019038076 0.09919840 ## VC/JC 0.004008016 0.024048096 0.008016032 0.05711423 ## UNI 0.000000000 0.003006012 0.001002004 0.03907816 ## ## $`1990` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.064 0.036 0.002 0.003 ## HS 0.070 0.368 0.028 0.105 ## VC/JC 0.009 0.070 0.024 0.121 ## UNI 0.001 0.009 0.002 0.088 ## ## $`2000` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.016016016 0.02002002 0.002002002 0.003003003 ## HS 0.039039039 0.33333333 0.040040040 0.106106106 ## VC/JC 0.008008008 0.09509510 0.048048048 0.162162162 ## UNI 0.001001001 0.01301301 0.006006006 0.107107107 ## ## $`2010` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.010 0.015 0.002 0.003 ## HS 0.028 0.236 0.044 0.075 ## VC/JC 0.011 0.122 0.081 0.164 ## UNI 0.002 0.028 0.018 0.161 上の出力結果を見ると調査年の前に$がついているが、これは返り値がリストになっていることを示している。$の後に続く文字列がリストの要素の名前になっているのでこれを用いて要素にアクセスできる。 TotProp &lt;- apply(EduWH, 3, proportions, simplify = FALSE) class(TotProp) ## [1] &quot;list&quot; TotProp$`1980` ## EduH ## EduW JHS HS VC/JC UNI ## JHS 0.211422846 0.080160321 0.003006012 0.00501002 ## HS 0.086172345 0.359719439 0.019038076 0.09919840 ## VC/JC 0.004008016 0.024048096 0.008016032 0.05711423 ## UNI 0.000000000 0.003006012 0.001002004 0.03907816 4.4 apply()と自作関数を組み合わせる 最後に、同類婚、すなわち夫婦の学歴が同じカテゴリの組み合わせ、の割合を調査年ごとに算出してみよう。一例として、これは以下の3ステップに分けて考えればよい。 任意の調査年の夫婦の学歴組み合わせのクロス表に対して、対角セルを取り出す 対角セルの各度数を全体度数で割る 1-2を全ての調査年について繰り返す まず、例として1980年のクロス表を対象にすると、1および2は以下のコードで実行できる。 ObsDiag &lt;- diag(EduWH1980) # diag():行列の対角成分を取得 PropDiag &lt;- ObsDiag / sum(EduWH1980) 問題はこうした処理を全ての調査年ごとに繰り返す（ステップ3）にはどうすればよいか、である。今回の例では非常に単純な処理なので、同じコードを調査年ごとに書き起こしても大きな問題はなさそうである。しかしながら、プログラミングの有名な原則「DRY（Don’t Repeat Yourself）原則」にも言われているように、できるだけできるだけコードの重複は避ける習慣はつけておいた方がよい（自戒）。そこで、上記のステップ1-2の処理を行う関数を作成してみよう。 prop_diag &lt;- function(x){ ObsDiag &lt;- diag(x) PropDiag &lt;- ObsDiag / sum(x) return(PropDiag) } これにより、引数として夫婦の学歴組み合わせからなる行列を引き渡すと、対角成分の比率が返り値として出力される関数が定義された。この自作関数とapply()を組み合わせることで、調査年ごとに同類婚の占める割合を算出することができる。 PropDiag_byCensus &lt;- apply(EduWH, 3, prop_diag) PropDiag_byCensus ## CensusYear ## EduW 1980 1990 2000 2010 ## JHS 0.211422846 0.064 0.01601602 0.010 ## HS 0.359719439 0.368 0.33333333 0.236 ## VC/JC 0.008016032 0.024 0.04804805 0.081 ## UNI 0.039078156 0.088 0.10710711 0.161 この場合、オプションのsimplify = FALSEを外しておくと、返り値が行列となり、その後の処理（出力結果を可視化する、CSVに書き出すなど）も容易になる。出力結果を行列ではなくてリストで得たい場合は、simplify = FALSEをつけておくとよい。 "],["data-visualization.html", "Chapter 5 Data Visualization 5.1 棒グラフ 5.2 折れ線グラフ 5.3 補足：クロス集計表の可視化", " Chapter 5 Data Visualization Rには極めて多彩なグラフの描画機能が搭載されている。そのため、R上で行なった処理結果を例えばExcelなどにコピペしてグラフを作成するのではなく、ぜひRの内部でグラフの描画まで完結させることを強く推奨する。昨今はtidyverseパッケージの一部であるggplot()を用いる方法がRコミュニティの中では優勢であるが、以下ではbase環境の中で伝統的に用いられてきた関数に基づいて説明する。 5.1 棒グラフ 棒グラフはbarplot()で作成できる。先に作成した、調査年ごとの同類婚の比率が格納されたPropDiag_byCensusを引数として渡すと、 PropDiag_byCensus ## CensusYear ## EduW 1980 1990 2000 2010 ## JHS 0.211422846 0.064 0.01601602 0.010 ## HS 0.359719439 0.368 0.33333333 0.236 ## VC/JC 0.008016032 0.024 0.04804805 0.081 ## UNI 0.039078156 0.088 0.10710711 0.161 barplot(PropDiag_byCensus) のように、デフォルトの設定では積み上げ棒グラフが描画される。このままでは論文にそのまま掲載できるような水準の体裁になっていないが、例えば以下のようにコードを書き加えれば（幾分）見栄えは向上する。 barplot(PropDiag_byCensus, ylim = c(0, 1), axes = FALSE, legend = rownames(PropDiag_byCensus)) axis(2, las = 1) mtext(&quot;Census Year&quot;, side = 1, line = 3) mtext(&quot;Proportions&quot;, side = 2, line = 3) title(&quot;Proportions of Homogamy, by Education and Census Year&quot;) 積み上げ棒グラフではなく、調査年・学歴別に棒グラフを描きたい場合は、beside = TRUEをオプションに加えばよい。 barplot(PropDiag_byCensus, beside = TRUE, ylim = c(0, 1), axes = FALSE, legend = rownames(PropDiag_byCensus)) axis(2, las = 1) mtext(&quot;Census Year&quot;, side = 1, line = 3) mtext(&quot;Proportions&quot;, side = 2, line = 3) title(&quot;Proportions of Homogamy, by Education and Census Year&quot;) 5.2 折れ線グラフ 折れ線グラフはplot()あるいはmatplot()を用いて描画できる。plot()に最低限必要な引数はx軸とy軸に対応するベクトルである。例として、調査年ごとに同類婚が占める割合を折れ線グラフにしてみよう。 # 調査年ごとに同類婚の合計比率を算出 PropHomg &lt;- apply(PropDiag_byCensus, 2, sum) PropHomg ## 1980 1990 2000 2010 ## 0.6182365 0.5440000 0.5045045 0.4880000 # 折れ線グラフを描く plot(x = seq(1980, 2010, 10), #&quot;x=&quot;は省略してもよい y = PropHomg, #&quot;y=&quot;は省略してもよい type = &quot;o&quot;, pch = 16, xlim = c(1980, 2010), ylim = c(0, 1), ann = FALSE, axes = FALSE) axis(1) axis(2, at = seq(0, 1, 0.25), las = 1) mtext(&quot;Census Year&quot;, side = 1, line = 3) mtext(&quot;Proportions&quot;, side = 2, line = 3) title(&quot;Proportions of Homogamy by Census Year&quot;) plot()の中で指定した引数について少しだけ補足すると以下の通りである。 type：線と点のどちらをプロットするか、あるいはその両者をプロットするか pch：点（マーカー）の種類 typeとpchの種類についてはplot()のヘルプページを参照されたい(コンソール画面に?plotと入力すればよい)。 matplot()はplot()の拡張版で、引数yに行列を指定できる。例えば、学歴別の同類婚がそれぞれ全夫婦に占める割合の変化をプロットしてみよう。 matplot(seq(1980, 2010, 10), t(PropDiag_byCensus), type = &quot;o&quot;, lty = 1, pch = 16, xlim = c(1980, 2010), ylim = c(0, 0.5), ann = FALSE, axes = FALSE) axis(1, at = seq(1980, 2010, 10)) axis(2, at = seq(0, 0.5, 0.1), las = 1) mtext(&quot;Census Year&quot;, side = 1, line = 3) mtext(&quot;Proportions&quot;, side = 2, line = 3) legend(&quot;topright&quot;, rownames(PropDiag_byCensus), lty = 1, pch = 16, col = 1:4, bty = &quot;n&quot;) 5.3 補足：クロス集計表の可視化 クロス表を可視化する方法として、以下ではモザイクプロット（mosaic plot）とバルーンプロット（balloon plot）について解説する。 5.3.1 モザイクプロット モザイクプロットは以下の特徴を持つ タイルの各辺の長さが行／列の変数の周辺分布を表す タイルの面積がセル度数の大きさを示す mosaicplot(t(EduWH1980), main = &quot;Distribution of Educational Pairings: 1980 Census&quot;) 5.3.2 バルーンプロット バルーンプロットは、セル度数に比例した大きさのマーカーをクロス表のセル上にプロットするものである。 library(gplots) EduWH1980_tab &lt;- as.table(EduWH1980) # tableクラスにしてから引き渡す必要がある balloonplot(x = t(EduWH1980_tab), main = &quot;&quot;, ylab = &quot;Wife&#39;s Education&quot;, xlab = &quot;Husband&#39;s Education&quot;) "],["reference.html", "Reference", " Reference "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
